@using HWDPortalMaui.Services
@using Microsoft.Maui.ApplicationModel
@inherits LayoutComponentBase
@inject UserInfoService UserInfo
@inject NavigationManager Navigation
@inject HWDPortalMaui.Services.UpdateService UpdateService
@inject AIAssistantService _aiAssistantService

@* 加入 @if 判斷式，只有在使用者有效或尚未完成初始化時才顯示主要內容 *@
@if (!UserInfo.IsInitialized)
{
    // 當使用者資訊服務尚未初始化時，顯示載入中畫面
    // 增加 d-flex 與相關 class，並設定 style 使其填滿整個可視高度以實現置中
    <div class="loading-container d-flex flex-column justify-content-center align-items-center" style="height: 100vh;">
        <div class="spinner-border text-primary" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Loading...</span>
        </div>
        <p class="mt-3 text-muted">正在驗證使用者身份，請稍候...</p>
    </div>
}
else if (UserInfo.IsUserValid)
{
    // 只有當使用者初始化完成且驗證有效時，才顯示主畫面
    <div class="page">
        <div class="sidebar">
            <NavMenu />
            <div class="sidebar-footer">
                <span>Version: @AppInfo.Current.VersionString</span>
            </div>
        </div>

        @* 加上 style 屬性以動態控制滾動條 *@
        <main style="@mainContentStyle">
            @* 使用 d-flex 與 justify-content-between 讓標題與使用者資訊分佔左右兩側 *@
            <div class="top-row px-4 d-flex justify-content-between align-items-center">
                @* 用於顯示頁面標題的區塊 *@
                <div>
                    <h5 class="mb-0">@_currentPageTitle</h5>
                </div>
                @* 改為使用 UserInfo.IsUserValid 來判斷 *@
                @if (UserInfo.IsUserValid && !string.IsNullOrEmpty(UserInfo.UserName))
                {
                    // 當使用者驗證成功時，顯示使用者資訊和選單
                    <div class="dropdown">
                        <a href="#" class="d-flex align-items-center text-dark text-decoration-none dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                            <i class="bi bi-person-circle me-2" style="font-size: 1.2rem; color: #343a40;"></i>
                            <span>@UserInfo.UserName</span> @* 直接從 UserInfo 服務顯示使用者名稱 *@
                        </a>
                        <ul class="dropdown-menu text-small shadow">
                            @* 在 MAUI Hybrid 應用中，身份驗證是跟隨 Windows 登入，
                               通常沒有傳統的 "登出" 按鈕，可以考慮移除此項目，或讓它關閉應用程式。
                            <li>
                                <a class="dropdown-item" href="#">
                                    <i class="bi bi-box-arrow-right me-2"></i>
                                    <span>登出</span>
                                </a>
                            </li>
                            *@
                        </ul>
                    </div>
                }
                else
                {
                    // 當使用者未通過驗證時，顯示此訊息
                    <span class="user-info">使用者: 未驗證</span>
                }
            </div>

            <article class="content px-4">
                @* 將 MainLayout 元件本身的實例(this)透過串聯參數傳遞給子元件 *@
                <CascadingValue Value="this">
                    @Body
                </CascadingValue>
            </article>
        </main>
    </div>
}
else
{
    // 當使用者已初始化但驗證失敗時的過渡畫面
    // 理論上此畫面只會出現一瞬間，因為 OnAfterRenderAsync 中的導航會立即觸發
    <div class="loading-container">
        <p class="mt-3 text-muted">驗證失敗，正在重新導向...</p>
    </div>
}

<div id="blazor-error-ui">
    An unhandled error has occurred.
    <a href="" class="reload">Reload</a>
    <a class="dismiss">🗙</a>
</div>

<div class="toast-container position-fixed top-50 start-50 translate-middle" style="z-index: 1080">
</div>

@code {
    private string? _currentPageTitle; // 用於儲存目前頁面標題的私有欄位

    // 一個旗標，確保驗證邏輯只在首次渲染後執行一次
    private bool _hasPerformedAuthCheck = false;
    private bool _hasPerformedUpdateCheck = false;

    // 用於儲存 <main> 元素樣式的變數
    private string mainContentStyle = "";
    // 建立一個公開方法，讓子元件(頁面)可以呼叫以設定標題
    public void SetPageTitle(string title)
    {
        _currentPageTitle = title;
        StateHasChanged(); // 通知 Blazor 狀態已變更，需要重新渲染 UI
    }
    // 公開方法，供 Dashboard 等子頁面呼叫以設定內容區塊的樣式
    public void SetContentOverflow(bool isMaximized)
    {
        // 如果 isMaximized 為 true，則設定 style="overflow: hidden;"，否則清空樣式
        mainContentStyle = isMaximized ? "overflow: hidden;" : "";
        StateHasChanged();
    }

   

    // 使用 OnAfterRenderAsync 來處理啟動時的驗證與導航
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // 只在首次渲染後執行
        if (firstRender)
        {
            // 執行更新檢查
            if (!_hasPerformedUpdateCheck)
            {
                _hasPerformedUpdateCheck = true;
                // 呼叫方法時，將此元件已注入的 Navigation 實例作為參數傳入
                await UpdateService.CheckForUpdateAsync(Navigation);
            }

            // --- 現有的身份驗證邏輯 ---
            if (!_hasPerformedAuthCheck)
            {
                _hasPerformedAuthCheck = true; // 將旗標設為 true，防止重複執行

                var userName = Environment.UserName;
                if (!string.IsNullOrEmpty(userName))
                {
                    // ... (此處的既有程式碼保持不變)
                    await UserInfo.InitializeAsync(userName);

                    if (UserInfo.IsInitialized && !UserInfo.IsUserValid)
                    {
                        Navigation.NavigateTo("/access-denied");
                        return;
                    }
                    // 當使用者資訊成功初始化後，才開始初始化 AI 助理服務
                    // 這樣可以確保 AIAssistantService 能正確取得到 UserName
                    if (UserInfo.IsUserValid)
                    {
                        // 將 AI 服務的初始化改為在背景執行，不等待其完成
                        // 如此可避免 UI 因等待網路請求而被卡住
                        _ = Task.Run(() => _aiAssistantService.InitializeAssistantAsync());
                    }
                }
                else
                {
                    Console.WriteLine("[Error] Unable to retrieve username from Environment.UserName.");
                    Navigation.NavigateTo("/access-denied");
                    return;
                }
                StateHasChanged();
            }
        }
    }

    
}