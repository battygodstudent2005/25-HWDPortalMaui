@page "/ee-design-check-tool/smbus-i2c-design-check"
@layout HWDPortalMaui.Components.Pages.EEDesignCheck.Layout.MainLayout_EEDesignTool
@* 引入 IO 與 Diagnostics 以支援檔案操作與外部程序呼叫 *@
@using System.IO
@using System.Diagnostics
@using System.Text
@using System.Text.RegularExpressions
@* 引入 Blazor.Diagrams 命名空間 *@
@using Blazor.Diagrams
@using Blazor.Diagrams.Core.Geometry
@using Blazor.Diagrams.Core.Models
@using Blazor.Diagrams.Components
@using HWDPortalMaui.Components.Widgets

<PageTitle>SMBus/I2C Design Check Tool</PageTitle>


<h1>SMBus/I2C Design Check Tool</h1>
@* 頁面主要容器與 Tab 導航 *@
<div class="container-fluid mt-3">

    @* Tab 導航列 *@
    <div class="card text-center">
        <div class="card-header">
            <ul class="nav nav-tabs card-header-tabs">
                <li class="nav-item">
                    <a class="nav-link @(activeTab == 0 ? "active" : "")" @onclick="() => activeTab = 0" href="javascript:void(0)">
                        <i class="bi bi-file-earmark-arrow-up"></i> 線路圖上傳 (DSN Input)
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link @(activeTab == 1 ? "active" : "")" @onclick="() => activeTab = 1" href="javascript:void(0)">
                        拓撲結構與連接性 (Items 1, 6)
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link @(activeTab == 2 ? "active" : "")" @onclick="() => activeTab = 2" href="javascript:void(0)">
                        位準轉換電路檢查 (Items 2, 3, 4)
                    </a>
                </li>
                <li class="nav-item">
                    <a class="nav-link @(activeTab == 3 ? "active" : "")" @onclick="() => activeTab = 3" href="javascript:void(0)">
                        通訊協定與配置 (Items 5, 7)
                    </a>
                </li>
            </ul>
        </div>

        <div class="card-body text-start">

            @* Tab 0 內容: 檔案上傳與分析啟動 *@
            @if (activeTab == 0)
            {
                <h5 class="card-title">上傳 OrCAD DSN 線路圖檔案</h5>
                <p class="card-text text-muted">請上傳專案的 .dsn 檔案以進行 I2C/SMBus 自動化檢查。</p>

                <div class="row justify-content-center mt-4 mb-4">
                    <div class="col-md-8">
                        <div class="card shadow-sm">
                            <div class="card-body text-center p-5 border border-2 border-dashed rounded">
                                <i class="bi bi-cloud-upload fs-1 text-primary mb-3"></i>

                                @* 原有的 InputFile 區塊 *@
                                <div class="mb-3">
                                    @* 改用按鈕呼叫 MAUI 原生檔案選擇器 *@
                                    <button class="btn btn-outline-primary w-100 py-2" @onclick="PickFile">
                                        <i class="bi bi-folder2-open"></i> 選擇 DSN 或 NET 檔案
                                    </button>
                                </div>

                                @if (uploadedFile != null)
                                {
                                    <div class="alert alert-success d-inline-block mt-2">
                                        @* FileResult 的屬性名稱略有不同 (Name -> FileName), 且無法直接取得 Size (需透過 FileInfo) *@
                                        <i class="bi bi-file-earmark-check"></i> 已選擇檔案: <strong>@uploadedFile.FileName</strong>
                                        @* 這裡省略大小顯示，或需在 C# 中另外計算 *@
                                    </div>
                                    <div class="mt-3">
                                        <button class="btn btn-primary btn-lg" @onclick="StartAnalysis" disabled="@isAnalyzing">
                                            @if (isAnalyzing)
                                            {
                                                <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                                <span> 分析中...</span>
                                            }
                                            else
                                            {
                                                <span><i class="bi bi-play-circle"></i> 開始分析線路</span>
                                            }
                                        </button>
                                    </div>
                                }

                                @if (!string.IsNullOrEmpty(analysisMessage))
                                {
                                    <div class="mt-3 text-muted">
                                        <small>@analysisMessage</small>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }

            @* Tab 1 內容: 拓撲結構 *@
            else if (activeTab == 1)
            {
                <h5 class="card-title">SMBUS/I2C 拓撲結構總覽</h5>
                <p class="card-text text-muted">檢視從 CPU/PCH/EC 到 Sink 端的完整路徑，以及 SMBUS Alert Pin 連接狀態。</p>

                <div class="card mb-4 border-primary">
                    <div class="card-header bg-primary text-white">
                        <i class="bi bi-gear-fill"></i> 主要控制器元件設定 (Key Component References)
                    </div>
                    <div class="card-body bg-light">
                        <div class="row g-3">
                            @* Part 輸入框 *@
                            <div class="col-md-3">
                                <label for="inputPart" class="form-label fw-bold">Part Ref Des:</label>
                                @* 修改綁定變數為 PartRef *@
                                <input type="text" class="form-control" id="inputPart" @bind="PartRef" placeholder="Ex: UC1" />
                                <div class="form-text">輸入指定元件在線路圖上的位置號 (如 UC1)</div>
                            </div>
                            @* targetRefNet 名稱篩選視窗 UI *@
                            <div class="col-md-3">
                                <label for="inputNetFilter" class="form-label fw-bold">Net Name Filter:</label>
                                <input type="text" class="form-control" id="inputNetFilter" @bind="NetNameFilter" placeholder="" />
                                <div class="form-text">輸入 Net 名稱關鍵字 (如 SMBCLK)</div>
                            </div>
                            @* Net Name 下拉選單 *@
                            <div class="col-md-3">
                                <label for="selectNetName" class="form-label fw-bold">Net Name Select:</label>
                                @* 綁定 SelectedNetName *@
                                <select class="form-select" id="selectNetName" @bind="SelectedNetName">
                                    <option value="">-- 請選擇 Net --</option>

                                    @* 改為遍歷經過篩選的 FilteredNetNames 屬性 *@
                                    @foreach (var netName in FilteredNetNames)
                                    {
                                        <option value="@netName">@netName</option>
                                    }
                                </select>
                                <div class="form-text">顯示連接 @PartRef 的 Net</div>
                            </div>
                            @* 啟動按鈕置於 Group 內右下方 *@
                            <div class="col-12 text-end mt-3">
                                <button class="btn btn-success" @onclick="RunTopologyCheck">
                                    <i class="bi bi-diagram-2-fill"></i> 啟動拓撲結構檢查
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                @* 只有在圖表準備好時才顯示 DiagramCanvas *@
                @if (isDiagramReady && MyDiagram != null)
                {
                    <div class="card shadow-sm">
                        @* 加入 d-flex justify-content-between align-items-center 以便左右對齊 *@
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <span><i class="bi bi-diagram-3"></i> 拓撲圖預覽</span>

                            @* 縮放工具列按鈕 *@
                            <div class="btn-group btn-group-sm">
                                <button type="button" class="btn btn-outline-secondary" @onclick="ZoomIn" title="放大">
                                    <i class="bi bi-zoom-in"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary" @onclick="ZoomOut" title="縮小">
                                    <i class="bi bi-zoom-out"></i>
                                </button>
                                <button type="button" class="btn btn-outline-secondary" @onclick="ZoomReset" title="重置 100%">
                                    <i class="bi bi-arrow-counterclockwise"></i> 重置
                                </button>
                                <button type="button" class="btn btn-outline-secondary" @onclick="ZoomToFit" title="適應視窗">
                                    <i class="bi bi-arrows-fullscreen"></i> 適應
                                </button>
                            </div>
                        </div>

                        @* overflow 改為 hidden，並加入 position-relative *@
                        <div class="card-body position-relative" style="height: 600px; overflow: hidden; background-color: #f8f9fa;">
                            <CascadingValue Value="MyDiagram">
                                <DiagramCanvas />
                            </CascadingValue>
                        </div>
                    </div>
                }
                else
                {
                    <div class="card shadow-sm">
                        <div class="card-body text-center p-5">
                            <i class="bi bi-info-circle text-muted" style="font-size: 3rem;"></i>
                            <p class="mt-3 text-muted">請點擊上方「啟動拓撲結構檢查」按鈕以產生拓撲圖</p>
                        </div>
                    </div>
                }

                @* 分析訊息顯示 *@
                @if (!string.IsNullOrEmpty(analysisMessage))
                {
                    <div class="alert alert-info mt-3">
                        <i class="bi bi-info-circle"></i> @analysisMessage
                    </div>
                }

            }

            @* Tab 2 內容: Level Shifter 綜合檢查 (最核心的電路檢查) *@
            else if (activeTab == 2)
            {
                <h5 class="card-title">位準轉換器 (Level Shifter) 電氣特性檢查</h5>
                <p class="text-muted">整合檢查：上拉電阻 (PU)、MOSFET Vgs 閾值與電源軌電壓。</p>

                <div class="table-responsive">
                    <table class="table table-bordered table-hover align-middle">
                        <thead class="table-light">
                            <tr>
                                <th>位置 (Location)</th>
                                <th>網路名稱 (Net Name)</th>
                                <th>電源軌檢查 (Item 4)</th>
                                <th>上拉電阻檢查 (Item 2)</th>
                                <th>MOSFET Vgs 檢查 (Item 3)</th>
                                <th>綜合判定</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var item in levelShifterResults)
                            {
                                <tr>
                                    <td><strong>@item.ComponentRef</strong></td>
                                    <td>@item.NetName</td>
                                    <td>
                                        <div>@item.PowerRail</div>
                                        <span class="badge @GetBadgeClass(item.PowerRailStatus)">@item.PowerRailStatus</span>
                                    </td>
                                    <td>
                                        <span class="badge @GetBadgeClass(item.PullUpStatus)">@item.PullUpStatus</span>
                                        @if (!string.IsNullOrEmpty(item.PullUpMessage))
                                        {
                                            <div class="small text-muted">@item.PullUpMessage</div>
                                        }
                                    </td>
                                    <td>
                                        <div class="small">Design: @item.DesignVgs V</div>
                                        <div class="small">Th: @item.ThresholdVgs V</div>
                                        <span class="badge @GetBadgeClass(item.VgsStatus)">@item.VgsStatus</span>
                                    </td>
                                    <td>
                                        @if (item.IsOverallFail)
                                        {
                                            <span class="text-danger fw-bold"><i class="bi bi-x-circle-fill"></i> FAIL</span>
                                        }
                                        else
                                        {
                                            <span class="text-success fw-bold"><i class="bi bi-check-circle-fill"></i> PASS</span>
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            }

            @* Tab 3 內容: 協定與配置 *@
            else if (activeTab == 3)
            {
                <h5 class="card-title">I2C 地址衝突與匯流排速度檢查</h5>
                <p class="text-muted">檢視同一 Bus 上的裝置地址是否重複，並確認速度設定一致性。</p>

                @foreach (var bus in busConfigResults)
                {
                    <div class="card mb-3 border-secondary">
                        <div class="card-header d-flex justify-content-between align-items-center bg-light">
                            <h6 class="mb-0 fw-bold"><i class="bi bi-hdd-network"></i> Bus: @bus.BusName</h6>
                            <div>
                                <span class="me-2">Item #7 Speed Check:</span>
                                <span class="badge @GetBadgeClass(bus.SpeedStatus)">@bus.SpeedStatus</span>
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                @foreach (var dev in bus.Devices)
                                {
                                    <div class="col-md-4 mb-2">
                                        <div class="p-2 border rounded @(dev.AddressStatus == CheckStatus.Fail ? "border-danger bg-danger-subtle" : "border-success")">
                                            <strong>@dev.DeviceName</strong>
                                            <div class="d-flex justify-content-between">
                                                <span>Addr: @dev.AddressHex</span>
                                                @if (dev.AddressStatus == CheckStatus.Fail)
                                                {
                                                    <span class="badge bg-danger">Conflict</span>
                                                }
                                                else
                                                {
                                                    <span class="badge bg-success">OK</span>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                }
            }
        </div>
    </div>
</div>

@code {
    // 預設改為 0，讓程式啟動時先顯示上傳頁面，引導使用者操作
    private int activeTab = 0;

    // 檔案上傳相關變數
    // 將 IBrowserFile 改為 MAUI 的 FileResult
    // private IBrowserFile? uploadedFile;
    private FileResult? uploadedFile;
    private bool isAnalyzing = false;
    private string analysisMessage = string.Empty;

    // 圖表準備狀態旗標
    private bool isDiagramReady = false;

    // 檢查狀態列舉
    public enum CheckStatus { Pass, Fail, Warning, Unknown }

    // 儲存解析後的 NetList 資料 ContentNetListArray[N] 的 範例內容為 [2][0] = NET_NAME("+0.9V_TBT_B_SVR"), [2][1] = Location ^ Pin ("RT176^1"), ... [2][X-1] = Location ^ Pin ("CT77^1"), 共有X-1個元件 在NET_NAME[0]上面
    private List<List<string>> ContentNetListArray = new List<List<string>>();

    // targetRefNet 名稱篩選變數 (目前僅用於 UI 綁定，內容維持空白)
    private string NetNameFilter { get; set; } = string.Empty;

    // Net Name 下拉選單綁定變數
    private string SelectedNetName { get; set; } = string.Empty;

    // 預設值可依據專案習慣設定，或留空
    private string PartRef { get; set; } = "UC1";

    // 定義 OrCAD 轉檔相關路徑 (建議之後可移至設定檔)
    private const string TempFolderPath = @"C:\powertooltemp";
    private const string OrCADScriptSourcePath = @"\\tpea31hwdfs01\Automation\自動化安裝軟體\OrCAD_Script\CreateNetList_24.1";
    private const string CaptureExePath = @"C:\Cadence\SPB_24.1\tools\bin\Capture.exe";

    // 定義 BlazorDiagram 物件 - 改為可空類型，延遲初始化
    private BlazorDiagram? MyDiagram { get; set; }

    // 用於拓撲圖每一層目前的 Y 軸高度紀錄，Key=LayerIndex, Value=CurrentY
    private Dictionary<int, int> layerYPositions = new Dictionary<int, int>();

    private async Task PickFile()
    {
        try
        {
            var customFileType = new FilePickerFileType(
                new Dictionary<DevicePlatform, IEnumerable<string>>
                {
                    { DevicePlatform.WinUI, new[] { ".dsn", ".net" } },
                    { DevicePlatform.macOS, new[] { "dsn", "net" } },
                });

            var options = new PickOptions
            {
                PickerTitle = "請選擇線路圖檔案 (.dsn, .net)",
                FileTypes = customFileType,
            };

            var result = await FilePicker.Default.PickAsync(options);

            if (result != null)
            {
                uploadedFile = result;
                analysisMessage = "檔案已準備就緒，請點擊「開始分析」。";
            }
        }
        catch (Exception ex)
        {
            analysisMessage = $"選擇檔案時發生錯誤: {ex.Message}";
        }
    }
    // 拓撲圖縮放控制方法
    private void ZoomIn()
    {
        if (MyDiagram != null)
        {
            // 每次放大 20%
            MyDiagram.SetZoom(MyDiagram.Zoom + 0.2);
        }
    }

    private void ZoomOut()
    {
        if (MyDiagram != null)
        {
            // 每次縮小 20%，設定下限避免過小
            var newZoom = MyDiagram.Zoom - 0.2;
            if (newZoom < 0.1) newZoom = 0.1;
            MyDiagram.SetZoom(newZoom);
        }
    }

    // 動態篩選清單屬性：根據 PartRef 與 Filter 關鍵字過濾
    private IEnumerable<string> FilteredNetNames
    {
        get
        {
            // 若無資料直接回傳空
            if (ContentNetListArray == null) return Enumerable.Empty<string>();

            var targetPart = PartRef?.Trim();
            var filterText = NetNameFilter?.Trim();

            // 查詢 ContentNetListArray
            return ContentNetListArray
                .Where(row =>
                {
                    if (row.Count == 0) return false;
                    string netName = row[0];

                    // 條件 1: 若有輸入篩選字串，需檢查 Net Name 是否包含該字串 (忽略大小寫)
                    if (!string.IsNullOrEmpty(filterText) && 
                        !netName.Contains(filterText, StringComparison.OrdinalIgnoreCase))
                    {
                        return false;
                    }

                    // 條件 2: 檢查該 Net 是否有連接到指定的 PartRef
                    // row 的結構: [0]=NetName, [1...N]="Ref^Pin"
                    if (!string.IsNullOrEmpty(targetPart))
                    {
                        // 檢查 row 中是否有任何一個 Pin 屬於 targetPart
                        bool isConnected = row.Skip(1).Any(pinStr => 
                            pinStr.StartsWith(targetPart + "^", StringComparison.OrdinalIgnoreCase));
                        
                        if (!isConnected) return false;
                    }

                    return true;
                })
                .Select(row => row[0]); // 只取出 Net Name
        }
    }

    private void ZoomReset()
    {
        if (MyDiagram != null)
        {
            // 重置縮放為 1.0 (100%) 並歸零位移
            MyDiagram.SetZoom(1.0);
            MyDiagram.SetPan(0, 0);
        }
    }

    private void ZoomToFit()
    {
        if (MyDiagram != null)
        {
            // 自動縮放以適應所有節點
            MyDiagram.ZoomToFit();
        }
    }
    // 模擬開始分析流程
    private async Task StartAnalysis()
    {
        if (uploadedFile == null) return;
        isAnalyzing = true;
        analysisMessage = "初始化環境中...";
        StateHasChanged();

        try
        {
            // 步驟 1: 建立暫存資料夾
            ResetTempFolder(TempFolderPath);

            // 步驟 2: 判斷副檔名並決定儲存檔名
            // Form1 邏輯：DSN 需命名為 0.DSN 以配合 Script; NET 檔則依原名或直接存入
            string extension = Path.GetExtension(uploadedFile.FileName).ToLower();
            string tempFileName = (extension == ".dsn") ? "0.DSN" : uploadedFile.FileName;
            string fullPath = Path.Combine(TempFolderPath, tempFileName);

            // 限制讀取大小 (50MB)
            long maxFileSize = 1024 * 1024 * 50;
            analysisMessage = $"正在儲存檔案至 {fullPath}...";
            StateHasChanged();

            // 將檔案寫入本機暫存區
            await using (var fileStream = new FileStream(fullPath, FileMode.Create))
            {
                // FileResult 的 OpenReadAsync 不需要參數
                using (var sourceStream = await uploadedFile.OpenReadAsync())
                {
                    await sourceStream.CopyToAsync(fileStream);
                }
            }

            // 步驟 3: 依照檔案類型執行對應邏輯
            if (extension == ".dsn")
            {
                // DSN 檔案處理前，先執行 OrCAD 設定檔複製
                analysisMessage = "正在設定 OrCAD 環境參數 (複製 Config)...";
                StateHasChanged();

                // 使用 Task.Run 執行檔案複製以避免卡住 UI
                await Task.Run(() => SetupOrCADConfig());

                // [Case A] DSN 檔案：需呼叫外部 EXE 轉成 Netlist
                analysisMessage = "正在呼叫 OrCAD Capture 產生 Netlist...";
                StateHasChanged();

                // 為了避免卡住 UI，使用 Task.Run 執行耗時的 Process 呼叫
                await Task.Run(() => ReadNetList_DSN(fullPath));

                // 轉檔完成後，Script 預設會產生 "0.NET" 於同目錄
                string generatedNetlistPath = Path.Combine(TempFolderPath, "0.NET");
                if (File.Exists(generatedNetlistPath))
                {
                    analysisMessage = "正在讀取生成的 Netlist...";
                    StateHasChanged();
                    // 讀取生成的 .NET 檔並存入 ContentNetListArray
                    ReadNetList_NET(generatedNetlistPath);
                }
                else
                {
                    throw new FileNotFoundException("OrCAD 轉檔失敗，未產生 0.NET 檔案。");
                }
            }
            else if (extension == ".net")
            {
                // [Case B] NET 檔案：直接讀取使用者上傳的檔案
                // 若使用者選取NET File, 則直接接續這步驟
                analysisMessage = "偵測到 Netlist 檔案，正在直接解析...";
                StateHasChanged();

                // 直接讀取並存入 ContentNetListArray
                ReadNetList_NET(fullPath);
            }
            else
            {
                throw new NotSupportedException($"不支援的檔案格式: {extension}。僅支援 .DSN, .NET");
            }

            activeTab = 1; // 切換到結果分頁
            analysisMessage = $"分析完成！共解析出 {ContentNetListArray.Count} 組 Net 資料。";
        }
        catch (Exception ex)
        {
            analysisMessage = $"錯誤: {ex.Message}";
            // 建議紀錄 Log: ex.StackTrace
        }
        finally
        {
            isAnalyzing = false;
            // 開發階段建議保留暫存檔以便除錯，正式發布可取消註解下方清除指令
            ResetTempFolder(TempFolderPath);
        }
    }
    // 設定 OrCAD Config 子程式：複製網路磁碟上的設定檔到本機 Cadence 目錄
    private void SetupOrCADConfig()
    {
        // 定義來源路徑
        string SetConfigPath = @"\\tpea31hwdfs01\Automation\Automation Software\OrCAD_Script\Cadence_SPB24_1 Setting File";

        try
        {
            // 確保來源路徑存在
            if (!Directory.Exists(SetConfigPath))
            {
                // 若網路路徑無法存取，視需求決定是否拋出例外或僅紀錄 Log
                // 這裡選擇拋出例外以中止後續 OrCAD 操作
                throw new DirectoryNotFoundException($"無法存取設定檔來源路徑: {SetConfigPath}");
            }

            // 執行複製動作 (參數: 來源, 目的, 是否覆蓋)

            // 1. Copy to C:\Cadence
            CopyDirectory(SetConfigPath, @"C:\Cadence", true);

            // 2. Copy to C:\Cadence\SPB_24.1\tools\capture
            CopyDirectory(SetConfigPath, @"C:\Cadence\SPB_24.1\tools\capture", true);

            // 3. Copy to C:\SPB_Data\cdssetup\OrCAD_Capture\24.1.0
            CopyDirectory(SetConfigPath, @"C:\SPB_Data\cdssetup\OrCAD_Capture\24.1.0", true);
        }
        catch (Exception ex)
        {
            // 捕捉複製過程中的錯誤 (如權限不足、路徑不存在等)
            throw new Exception($"OrCAD 環境設定失敗: {ex.Message}");
        }
    }
    // 資料模型：Level Shifter 檢查結果
    public class LevelShifterCheckResult
    {
        public string ComponentRef { get; set; } = string.Empty;
        public string NetName { get; set; } = string.Empty;

        // Item 4
        public string PowerRail { get; set; } = string.Empty;
        public CheckStatus PowerRailStatus { get; set; }

        // Item 2
        public CheckStatus PullUpStatus { get; set; }
        public string PullUpMessage { get; set; } = string.Empty;

        // Item 3
        public double ThresholdVgs { get; set; }
        public double DesignVgs { get; set; }
        public CheckStatus VgsStatus { get; set; }

        // 判斷是否整體失敗
        public bool IsOverallFail => PowerRailStatus == CheckStatus.Fail || PullUpStatus == CheckStatus.Fail || VgsStatus == CheckStatus.Fail;
    }
    // 輔助方法：判斷是否為感興趣的 Net (讀取 SelectedNetName)
    private bool IsInterestingNet(string netName)
    {
        // 若使用者未選擇任何 Net (SelectedNetName 為空)，則回傳 false
        if (string.IsNullOrEmpty(SelectedNetName)) return false;

        // 直接比對傳入的 netName 是否等於使用者選擇的 SelectedNetName (忽略大小寫)
        return netName.Equals(SelectedNetName, StringComparison.OrdinalIgnoreCase);
    }

    // 輔助方法：過濾電源與地線，避免拓撲圖發散
    private bool IsPowerOrGroundNet(string netName)
    {
        var upper = netName.ToUpper();
        //常見電源命名規則
        if (upper.StartsWith("+") || upper.Contains("GND") || upper.Contains("VCC") || upper.Contains("VDD") || upper.Contains("VSS"))
        {
            return true;
        }
        return false;
    }
    // RunTopologyCheck 方法，改為支援多層級追蹤
    private async Task RunTopologyCheck()
    {
        try
        {
            // 強制重置圖表狀態
            isDiagramReady = false;
            // 明確將 MyDiagram 設為 null
            MyDiagram = null;
            StateHasChanged();

            // 加入短暫延遲 (例如 50ms)。
            //這會強制讓 UI 執行緒先完成 "隱藏圖表" 的渲染動作，避免新舊圖表切換時 DOM 未即時更新。
            await Task.Delay(50);

            analysisMessage = $"正在執行深度拓撲檢查... 目標: Part[{PartRef}]";

            // 初始化 Diagram
            MyDiagram = new BlazorDiagram();

            // 註冊 PowerNodeModel 對應的 Widget
            MyDiagram.RegisterComponent<PowerNodeModel, PowerNodeWidget>();

            // 註冊選取變更事件，用於點擊 Highlight 功能
            MyDiagram.SelectionChanged += OnSelectionChanged;

            MyDiagram.Options.Links.DefaultRouter = new Blazor.Diagrams.Core.Routers.NormalRouter();
            MyDiagram.Options.Zoom.Enabled = true;
            MyDiagram.Options.AllowMultiSelection = false;

            // 暫停刷新以提升效能，避免在迴圈中頻繁重繪
            MyDiagram.SuspendRefresh = true;

            // 重置層級高度紀錄與訪問紀錄
            layerYPositions.Clear();
            HashSet<string> visitedComponents = new HashSet<string>();
            HashSet<string> visitedNets = new HashSet<string>();

            // 建立節點查找表，避免重複建立 Node (Key: RefDes, Value: NodeModel)
            Dictionary<string, NodeModel> nodeLookup = new Dictionary<string, NodeModel>();

            // 定義 起點 預設位置
            int startX = 50;
            int startY = 300;
            // 取得目標元件 Ref (將 CpuRef 改為 PartRef)
            string targetRef = string.IsNullOrEmpty(PartRef) ? "U1" : PartRef;

            // 建立 Root (CPU) 節點
            var cpuNode = new NodeModel(position: new Point(startX, startY))
            {
                Title = targetRef,
                Locked = true
            };
            var cpuPort = cpuNode.AddPort(PortAlignment.Right); // CPU 輸出埠
            MyDiagram.Nodes.Add(cpuNode);

            // 加入查找表與已訪問清單
            nodeLookup.Add(targetRef, cpuNode);
            visitedComponents.Add(targetRef);

            // 定義 BFS 佇列
            // Tuple 結構: (當前元件 Ref, 來源節點 NodeModel, 來源 PortModel, 連接過來的 Net 名稱, 目前層級 Layer)
            Queue<(string CompRef, NodeModel SourceNode, PortModel SourcePort, string ViaNetName, int Layer)> bfsQueue
                = new Queue<(string, NodeModel, PortModel, string, int)>();

            // ---------------------------------------------------------
            // 步驟 1: 找出 CPU 第一層包含 "SMBCLK", "I2C" 等關鍵字的起始 Net
            // ---------------------------------------------------------
            foreach (var netRow in ContentNetListArray)
            {
                string netName = netRow[0].ToString();

                // 寬鬆過濾條件，只要包含關鍵字且不是電源地線
                if (IsInterestingNet(netName) && !IsPowerOrGroundNet(netName))
                {
                    // 檢查此 Net 是否連到 CPU
                    bool isCpuInThisNet = false;
                    for (int i = 1; i < netRow.Count; i++)
                    {
                        if (netRow[i].Split('^')[0].Equals(targetRef, StringComparison.OrdinalIgnoreCase))
                        {
                            isCpuInThisNet = true;
                            break;
                        }
                    }

                    if (isCpuInThisNet)
                    {
                        // 將此 Net 上的其他元件加入佇列 (Layer 1)
                        foreach (var pinInfo in netRow.Skip(1)) // 跳過 netName
                        {
                            string compRef = pinInfo.Split('^')[0];
                            if (!compRef.Equals(targetRef, StringComparison.OrdinalIgnoreCase))
                            {
                                // 加入佇列，準備在 While 迴圈中建立節點
                                bfsQueue.Enqueue((compRef, cpuNode, cpuPort, netName, 1));
                            }
                        }
                        visitedNets.Add(netName); // 標記此 Net 已處理，避免重複
                    }
                }
            }

            // ---------------------------------------------------------
            // 步驟 2: 開始 BFS 迴圈，層層展開
            // ---------------------------------------------------------
            // 設定最大深度防止無限迴圈 (例如設為 5 層)
            int maxDepth = 5;

            while (bfsQueue.Count > 0)
            {
                var currentItem = bfsQueue.Dequeue();
                string currentRef = currentItem.CompRef;
                NodeModel sourceNode = currentItem.SourceNode;
                PortModel sourcePort = currentItem.SourcePort; // 來源的 Port (上一層的輸出)
                string incomingNetName = currentItem.ViaNetName;
                int currentLayer = currentItem.Layer;

                if (currentLayer > maxDepth) continue;

                // 處理節點建立 (如果已存在就共用，如果是新的就建立)
                NodeModel currentNode;
                PortModel inputPort; // 用於接收來源訊號的 Port (左側)

                if (nodeLookup.ContainsKey(currentRef))
                {
                    currentNode = nodeLookup[currentRef];
                    // 嘗試取得左側 Port，若無則新增 (用於接收)
                    inputPort = currentNode.Ports.FirstOrDefault(p => p.Alignment == PortAlignment.Left)
                                ?? currentNode.AddPort(PortAlignment.Left);
                }
                else
                {
                    // 計算位置
                    int nodeX = startX + (currentLayer * 400); // 每層 X 間距 400

                    // 取得該層目前的 Y，若無則從 50 開始
                    if (!layerYPositions.ContainsKey(currentLayer)) layerYPositions[currentLayer] = 50;

                    int nodeY = layerYPositions[currentLayer];

                    currentNode = new NodeModel(position: new Point(nodeX, nodeY))
                    {
                        Title = currentRef,
                        Locked = true
                    };
                    inputPort = currentNode.AddPort(PortAlignment.Left); // 左側 Input
                    MyDiagram.Nodes.Add(currentNode);

                    nodeLookup.Add(currentRef, currentNode);
                    visitedComponents.Add(currentRef);

                    // 更新該層的 Y 軸高度，保留間距 (例如 120)
                    layerYPositions[currentLayer] += 120;
                }

                // 建立連線 (從上一層連過來)
                // Z.Blazor.Diagrams v3+ 使用 Source/Target Anchor，需轉型為 SinglePortAnchor 才能取得 Port
                bool linkExists = MyDiagram.Links
                    .OfType<LinkModel>()
                    .Any(l => (l.Source as Blazor.Diagrams.Core.Anchors.SinglePortAnchor)?.Port == sourcePort &&
                              (l.Target as Blazor.Diagrams.Core.Anchors.SinglePortAnchor)?.Port == inputPort);

                if (!linkExists)
                {
                    var link = new LinkModel(sourcePort, inputPort);
                    link.TargetMarker = LinkMarker.Arrow;
                    link.Color = "#6c757d"; // 灰色線條

                    // 加入 Net Name 標籤
                    var linkLabel = new Blazor.Diagrams.Core.Models.LinkLabelModel(link, incomingNetName)
                    {
                        Distance = 1.00, // 標籤置中
                        Offset = new Point(-60, 15) // 稍微往左下
                    };
                    link.Labels.Add(linkLabel);
                    MyDiagram.Links.Add(link);
                }

                // 檢查 currentRef 是否以 "U" 或 "J" 開頭
                if (currentRef.StartsWith("U", StringComparison.OrdinalIgnoreCase) ||
                    currentRef.StartsWith("J", StringComparison.OrdinalIgnoreCase) )
                {
                    // 雖然畫出了這個元件，但不將其下一層加入 Queue，直接換下一個處理
                    continue;
                }

                // ---------------------------------------------------------
                // 步驟 3: 尋找此元件 "延伸出去" 的 Net (往下一層找)
                // ---------------------------------------------------------
                // 為該節點新增一個右側輸出 Port，供下一層使用
                var outputPort = currentNode.Ports.FirstOrDefault(p => p.Alignment == PortAlignment.Right)
                                 ?? currentNode.AddPort(PortAlignment.Right);

                foreach (var netRow in ContentNetListArray)
                {
                    string nextNetName = netRow[0].ToString();

                    // 1. 忽略來源 Net (避免回頭)
                    if (nextNetName == incomingNetName) continue;

                    // 2. 優先檢查連接性：確認目前的 NetList Row 是否真的包含當前元件 (currentRef)
                    // 如果這個 Net 上面沒有目前的元件，代表無關，直接跳過
                    bool doesNetContainCurrentComp = false;
                    foreach (var pin in netRow.Skip(1)) // Skip netName
                    {
                        if (pin.Split('^')[0].Equals(currentRef, StringComparison.OrdinalIgnoreCase))
                        {
                            doesNetContainCurrentComp = true;
                            break;
                        }
                    }

                    if (!doesNetContainCurrentComp) continue;

                    // 3. 處理電源與地線 (確認有連接後才執行)
                    // 條件：開頭為 + 或包含 GND, VCC, VDD, VSS
                    if (IsPowerOrGroundNet(nextNetName))
                    {
                        // 計算電源節點位置 (放在下一層)
                        int nextLayer = currentLayer + 1;
                        int nodeX = startX + (nextLayer * 400);

                        // 取得該層目前的 Y
                        if (!layerYPositions.ContainsKey(nextLayer)) layerYPositions[nextLayer] = 50;
                        int nodeY = layerYPositions[nextLayer];

                        // 建立電源節點
                        // 改用 PowerNodeModel 來建立圓形節點
                        // var powerNode = new NodeModel(position: new Point(nodeX, nodeY))
                        var powerNode = new PowerNodeModel(position: new Point(nodeX, nodeY))
                        {
                            // 將 Title 設為 NetName 以便在 Tooltip 顯示，但在 Widget 中可選擇不顯示文字
                            Title = nextNetName,
                            Locked = true
                        };

                        var powerInputPort = powerNode.AddPort(PortAlignment.Left);
                        MyDiagram.Nodes.Add(powerNode);

                        // 更新 Y 軸高度 (電源節點通常較小，間距設小一點)
                        layerYPositions[nextLayer] += 80;

                        // 建立連線 (紅色以示區別)
                        var pLink = new LinkModel(outputPort, powerInputPort);
                        pLink.TargetMarker = LinkMarker.Arrow;
                        pLink.Color = "#dc3545"; // 使用紅色線條

                        // 加入 Net Name 標籤
                        pLink.Labels.Add(new Blazor.Diagrams.Core.Models.LinkLabelModel(pLink, nextNetName)
                        {
                            Distance = 1.00,
                            Offset = new Point(-60, -40)
                        });
                        MyDiagram.Links.Add(pLink);

                        // [關鍵] 電源/地線為終端節點，停止往後找
                        continue;
                    }

                    // 4. 一般訊號處理 (因為前面已經檢查過 doesNetContainCurrentComp，這裡直接處理 Queue)
                    // 忽略已經走過的 Net
                    if (visitedNets.Contains(nextNetName)) continue;

                    // 將 Net 上的其他元件加入 Queue
                    foreach (var pinInfo in netRow.Skip(1))
                    {
                        string nextCompRef = pinInfo.Split('^')[0];

                        // 避免回頭路：不要加自己，也不要加 CPU
                        if (!nextCompRef.Equals(currentRef, StringComparison.OrdinalIgnoreCase) &&
                            !nextCompRef.Equals(targetRef, StringComparison.OrdinalIgnoreCase))
                        {
                            bfsQueue.Enqueue((nextCompRef, currentNode, outputPort, nextNetName, currentLayer + 1));
                        }
                    }
                    // 標記此 Net 已處理
                    visitedNets.Add(nextNetName);
                }
            }

            // 恢復刷新並重繪
            MyDiagram.SuspendRefresh = false;
            // 1. 先設定 Flag 讓 UI 顯示 Canvas
            isDiagramReady = true;
            analysisMessage = $"拓撲檢查完成！已產生 {MyDiagram.Nodes.Count} 個節點，{MyDiagram.Links.Count} 條連線 (深度: {maxDepth})。";

            // 2. 強制 UI 渲染 (此時 <DiagramCanvas> 會被加入 DOM，但位置尚未計算完全)
            StateHasChanged();

            // 3. 關鍵：等待 DOM 渲染完成 (給予瀏覽器 Layout 時間)
            // 電源節點是自定義 Widget，需要實際渲染後才能取得 Port 的正確座標
            await Task.Delay(50);

            // 4. 現在 DOM 元素都存在了，執行 Refresh 來計算連線路徑
            MyDiagram.Refresh();
        }
        catch (Exception ex)
        {
            analysisMessage = $"拓撲檢查錯誤: {ex.Message}\n{ex.StackTrace}";
            isDiagramReady = false;
            MyDiagram = null;
            StateHasChanged();
        }
    }
    // 當圖表上的物件選取狀態改變時觸發
    private void OnSelectionChanged(Blazor.Diagrams.Core.Models.Base.Model model)
    {
        // 取得目前所有被選取的物件
        var selectedModels = MyDiagram?.GetSelectedModels();
        // 如果沒有選取任何東西，或者選取的是 Node (不是線)，則重置顏色
        if (selectedModels == null || !selectedModels.Any())
        {
            ResetLinkColors();
            MyDiagram?.Refresh();
            // 確保 UI 立即更新
            StateHasChanged();
            return;
        }

        // 檢查是否選取了 Link (連線)
        var selectedLink = selectedModels.FirstOrDefault(m => m is LinkModel) as LinkModel;
        if (selectedLink != null)
        {
            // 嘗試從 Link 的 Label 取得 Net Name
            // 假設 Label[0] 存放 Net Name (依照我們建立 Link 的邏輯)
            var labelModel = selectedLink.Labels.FirstOrDefault() as Blazor.Diagrams.Core.Models.LinkLabelModel;
            if (labelModel != null && !string.IsNullOrEmpty(labelModel.Content))
            {
                string selectedNetName = labelModel.Content;
                HighlightNet(selectedNetName);
            }
        }
        else
        {
            // 如果選到的不是 Link (例如選到 Node)，為了避免混淆，也可以選擇重置或保持現狀
            // 這裡選擇重置，讓畫面乾淨
            ResetLinkColors();
        }

        MyDiagram?.Refresh();

        // 強制 Blazor 元件重繪，解決點選後需滑鼠滑過才變色的問題
        StateHasChanged();
    }

    private void HighlightNet(string targetNetName)
    {
        if (MyDiagram == null) return;


        foreach (var link in MyDiagram.Links.OfType<LinkModel>())
        {
            // 取得該 Link 的 Net Name
            var label = link.Labels.FirstOrDefault() as Blazor.Diagrams.Core.Models.LinkLabelModel;
            string linkNetName = label?.Content ?? string.Empty;

            // 比對名稱 (忽略大小寫)
            if (linkNetName.Equals(targetNetName, StringComparison.OrdinalIgnoreCase))
            {
                // 設為綠色 (Bootstrap Success Color)
                link.Color = "#198754";
                // 加粗線條 (選用)
                link.Width = 4;
            }
            else
            {
                // 非相關連線，設為淡灰色或原本的深灰色
                link.Color = "#dee2e6";
                // 變淡，凸顯綠色
                link.Width = 2;
            }

            // 通知該 Link 進行重繪
            link.Refresh();
        }

    }

    // 重置所有連線顏色為預設值
    private void ResetLinkColors()
    {
        if (MyDiagram == null) return;

        foreach (var link in MyDiagram.Links.OfType<LinkModel>())
        {
            // 判斷是否為電源線 (紅色) 或一般訊號線 (灰色)
            var label = link.Labels.FirstOrDefault() as Blazor.Diagrams.Core.Models.LinkLabelModel;
            string netName = label?.Content ?? string.Empty;

            if (IsPowerOrGroundNet(netName))
            {
                link.Color = "#dc3545"; // Red
            }
            else
            {
                link.Color = "#6c757d"; // Gray
            }

            link.Width = 2; // 預設寬度

            // 通知該 Link 進行重繪
            link.Refresh();
        }

        // MyDiagram.SuspendRefresh = false; // [移除]
    }

    // 資料模型：Bus 配置與地址檢查
    public class BusConfigurationResult
    {
        public string BusName { get; set; } = string.Empty;
        public List<DeviceConfig> Devices { get; set; } = new();
        public CheckStatus SpeedStatus { get; set; } // Item 7
    }

    public class DeviceConfig
    {
        public string DeviceName { get; set; } = string.Empty;
        public string AddressHex { get; set; } = string.Empty;
        public CheckStatus AddressStatus { get; set; } // Item 5
    }

    // 模擬資料容器
    private List<LevelShifterCheckResult> levelShifterResults = new();
    private List<BusConfigurationResult> busConfigResults = new();

    protected override void OnInitialized()
    {
        // 初始化模擬資料 (對應 PPT 範例)
        LoadDummyData();
    }

    private void LoadDummyData()
    {
        // 模擬 Item 2, 3, 4 的資料
        levelShifterResults = new List<LevelShifterCheckResult>
        {
            new LevelShifterCheckResult
            {
                ComponentRef = "Q1802",
                NetName = "PCH_SML_SCL_PD",
                PowerRail = "+1P8V_S5",
                PowerRailStatus = CheckStatus.Pass,
                PullUpStatus = CheckStatus.Pass,
                DesignVgs = 1.8,
                ThresholdVgs = 1.1,
                VgsStatus = CheckStatus.Pass
            },
            new LevelShifterCheckResult
            {
                ComponentRef = "Q1703",
                NetName = "HDMI1_SCL_SNK",
                PowerRail = "Unknown", // 模擬 PPT 中無法判斷 Power Rail 的情況
                PowerRailStatus = CheckStatus.Fail,
                PullUpStatus = CheckStatus.Warning,
                PullUpMessage = "Manual Check Required",
                DesignVgs = 0,
                ThresholdVgs = 1.1,
                VgsStatus = CheckStatus.Fail
            }
        };

        // 模擬 Item 5, 7 的資料
        busConfigResults = new List<BusConfigurationResult>
        {
            new BusConfigurationResult
            {
                BusName = "SMBCLK/SMBDATA",
                SpeedStatus = CheckStatus.Pass,
                Devices = new List<DeviceConfig>
                {
                    new DeviceConfig { DeviceName = "DM1", AddressHex = "0x50", AddressStatus = CheckStatus.Fail }, // 重複地址
                    new DeviceConfig { DeviceName = "DM2", AddressHex = "0x50", AddressStatus = CheckStatus.Fail }, // 重複地址
                    new DeviceConfig { DeviceName = "DX1", AddressHex = "0x60", AddressStatus = CheckStatus.Pass }
                }
            },
            new BusConfigurationResult
            {
                BusName = "DDP1_CTRL",
                SpeedStatus = CheckStatus.Pass,
                Devices = new List<DeviceConfig>
                {
                    new DeviceConfig { DeviceName = "DP1", AddressHex = "0x3A", AddressStatus = CheckStatus.Pass },
                    new DeviceConfig { DeviceName = "HDMI1", AddressHex = "0x40", AddressStatus = CheckStatus.Pass }
                }
            }
        };
    }

    // 輔助方法：取得 Badge 樣式
    private string GetBadgeClass(CheckStatus status) => status switch
    {
        CheckStatus.Pass => "bg-success",
        CheckStatus.Fail => "bg-danger",
        CheckStatus.Warning => "bg-warning text-dark",
        _ => "bg-secondary"
    };
    // 讀取並處理 DSN 檔案
    private void ReadNetList_DSN(string _DSNfile)
    {
        // 定義 CMD Command
        // 注意：路徑中的斜線方向需符合 TCL 語法，這裡維持 Form1 的寫法
        string tclScriptPath = $"{TempFolderPath}/start-create-netlist.tcl".Replace("\\", "/");
        string CMD_Command = $@"{CaptureExePath} -batch -tcl ""{tclScriptPath}""";

        try
        {
            // 複製 Script File (從網芳或其他來源)
            // 注意：需確保執行此 App 的電腦有權限存取 OrCADScriptSourcePath
            if (!CopyDirectory(OrCADScriptSourcePath, TempFolderPath, true))
            {
                throw new Exception($"無法複製 Script 檔案，來源: {OrCADScriptSourcePath}");
            }

            // 執行 CMD
            RunScriptUsingCMD(CMD_Command);
        }
        catch (Exception ex)
        {
            // 容錯機制：OrCAD 24.1 可能會輸出大量 Web/License 雜訊導致誤判失敗
            // 這裡檢查目標檔案 "0.NET" 是否已經順利產生
            string expectedOutputFile = Path.Combine(TempFolderPath, "0.NET");

            if (File.Exists(expectedOutputFile))
            {
                // 若檔案存在，代表轉檔其實成功了，忽略這個錯誤
                // 您可以使用 Console.WriteLine 或 Debug.WriteLine 紀錄一下
                Debug.WriteLine($"[Warning] OrCAD 雖然回報錯誤但檔案已產生，忽略錯誤。訊息: {ex.Message}");
                return;
            }

            // 若檔案真的不存在，才拋出例外
            throw new Exception($"ReadNetList_DSN 執行失敗: {ex.Message}");
        }
    }

    // 執行 CMD 指令
    private void RunScriptUsingCMD(string cmdCommand)
    {
        using (Process process = new Process())
        {
            process.StartInfo.FileName = "cmd.exe";
            process.StartInfo.Arguments = $"/c {cmdCommand}";
            process.StartInfo.UseShellExecute = false;
            process.StartInfo.RedirectStandardOutput = true;
            process.StartInfo.RedirectStandardError = true;
            process.StartInfo.CreateNoWindow = true;

            process.Start();

            string output = process.StandardOutput.ReadToEnd();
            string error = process.StandardError.ReadToEnd();

            process.WaitForExit();

            // Form1.cs 中如果 error 不為空則拋出異常，這在 OrCAD 輸出警告時可能會導致中斷
            // 建議根據實際情況決定是否要 throw
            if (!string.IsNullOrEmpty(error) && process.ExitCode != 0)
            {
                throw new Exception($"CMD 執行錯誤: {error}");
            }
        }
    }

    // 讀取 NET 檔案內容 (移植自 Form1.cs)
    private void ReadNetList_NET(string _filePath)
    {
        try
        {
            string fileContent = File.ReadAllText(_filePath);
            ParseFileTo2DArray(fileContent);
        }
        catch (Exception ex)
        {
            throw new Exception($"讀取 NET 檔案失敗: {ex.Message}");
        }
    }

    // 解析 NetList 字串至 List (移植自 Form1.cs)
    private void ParseFileTo2DArray(string _fileContent)
    {
        // 清除之前的內容
        ContentNetListArray.Clear();

        var lines = _fileContent.Split(new[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
        List<string>? currentNet = null;

        foreach (var line in lines)
        {
            var trimmedLine = line.Trim();
            if (trimmedLine.StartsWith("(net "))
            {
                if (currentNet != null)
                {
                    ContentNetListArray.Add(currentNet);
                }

                currentNet = new List<string>
                {
                    // 提取網路名稱 (net "NAME") -> NAME
                    trimmedLine.Substring(6, trimmedLine.Length - 7).Trim()
                };
            }
            else if (trimmedLine.StartsWith("(node") && currentNet != null)
            {
                var parts = trimmedLine.Split('"');
                if (parts.Length > 3)
                {
                    currentNet.Add(parts[1] + "^" + parts[3]);
                }
            }
        }

        // 將最後一組加入
        if (currentNet != null)
        {
            ContentNetListArray.Add(currentNet);
        }
    }

    // 資料夾複製工具 (移植自 Form1.cs)
    private bool CopyDirectory(string sourcePath, string destinationPath, bool overwriteExisting)
    {
        bool ret = false;
        try
        {
            sourcePath = sourcePath.EndsWith(@"\") ? sourcePath : sourcePath + @"\";
            destinationPath = destinationPath.EndsWith(@"\") ? destinationPath : destinationPath + @"\";

            if (Directory.Exists(sourcePath))
            {
                if (!Directory.Exists(destinationPath))
                    Directory.CreateDirectory(destinationPath);

                foreach (string fls in Directory.GetFiles(sourcePath))
                {
                    FileInfo flinfo = new FileInfo(fls);
                    flinfo.CopyTo(destinationPath + flinfo.Name, overwriteExisting);
                }

                foreach (string drs in Directory.GetDirectories(sourcePath))
                {
                    DirectoryInfo drinfo = new DirectoryInfo(drs);
                    if (!CopyDirectory(drs, destinationPath + drinfo.Name, overwriteExisting))
                        ret = false;
                }
            }
            ret = true;
        }
        catch
        {
            ret = false;
        }
        return ret;
    }

    // 建立/清空暫存資料夾
    private void ResetTempFolder(string directoryPath)
    {
        try
        {
            if (Directory.Exists(directoryPath))
            {
                string[] files = Directory.GetFiles(directoryPath);
                foreach (string file in files)
                {
                    try { File.Delete(file); } catch { }
                }
            }
            else
            {
                Directory.CreateDirectory(directoryPath);
            }
        }
        catch { }
    }
}