<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>HWDPortalMaui</title>
    <base href="/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link rel="stylesheet" href="css/app.css" />
    <link rel="stylesheet" href="HWDPortalMaui.styles.css" />
    <link rel="icon" type="image/png" href="favicon.png" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
</head>

<body>

    <div class="status-bar-safe-area"></div>

    <div id="app">Loading...</div>

    <div id="blazor-error-ui">
        An unhandled error has occurred.
        <a href="" class="reload">Reload</a>
        <a class="dismiss">🗙</a>
    </div>

    <script src="_framework/blazor.webview.js" autostart="false"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // 定義全域的 showToast 函式
        window.showToast = (message, type) => {
            // 根據傳入的 type 決定 icon 和背景顏色
            const toastDetails = {
                success: { icon: 'bi-check-circle-fill', bgClass: 'bg-success' },
                danger: { icon: 'bi-x-circle-fill', bgClass: 'bg-danger' },
                warning: { icon: 'bi-exclamation-triangle-fill', bgClass: 'bg-warning' },
                info: { icon: 'bi-info-circle-fill', bgClass: 'bg-info' }
            };

            const details = toastDetails[type] || toastDetails.info; // 如果 type 無效，預設使用 info
            const toastContainer = document.querySelector('.toast-container');
            if (!toastContainer) return;

            // 動態建立 Toast 的 HTML 結構
            const toastElement = document.createElement('div');
            toastElement.className = `toast align-items-center text-white ${details.bgClass} border-0`;
            toastElement.setAttribute('role', 'alert');
            toastElement.setAttribute('aria-live', 'assertive');
            toastElement.setAttribute('aria-atomic', 'true');

            toastElement.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            <i class="bi ${details.icon} me-2"></i>
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                `;

            // 將建立好的 Toast 元素加入到容器中
            toastContainer.appendChild(toastElement);

            // 建立 Bootstrap Toast 實例並顯示
            const toast = new bootstrap.Toast(toastElement, {
                delay: 1000 // 1 秒後自動消失
            });

            // 監聽 Toast 關閉事件，並在關閉後從 DOM 中移除元素，避免元素堆積
            toastElement.addEventListener('hidden.bs.toast', () => {
                toastElement.remove();
            });

            toast.show();
        };
        // 調整右鍵選單位置，避免超出可視範圍
        function adjustContextMenuPosition() {
            // 1. 找到 Blazor 剛渲染出來的選單
            var menu = document.querySelector('.context-menu');
            if (!menu) {
                return; // 如果找不到選單，則不執行
            }

            // 2. 取得選單的尺寸和當前視窗的高度
            var menuHeight = menu.offsetHeight;
            var menuWidth = menu.offsetWidth;
            var viewportHeight = window.innerHeight;
            var viewportWidth = window.innerWidth;

            // 3. 取得 Blazor 設定的初始點擊位置 (從 style 讀取)
            var currentTop = parseInt(menu.style.top, 10);
            var currentLeft = parseInt(menu.style.left, 10);

            var newTop = currentTop;
            var newLeft = currentLeft;

            // 4. 檢查垂直是否溢出 (核心修正)
            // 如果 (選單的頂部 + 選單的高度) > 視窗高度
            if (currentTop + menuHeight > viewportHeight) {
                // 將選單的頂部位置改為 (視窗高度 - 選單高度 - 5px緩衝)
                newTop = viewportHeight - menuHeight - 5;

                // 額外處理：如果選單比視窗還高，至少讓它從頂部 0 開始
                if (newTop < 0) {
                    newTop = 0;
                }
            }

            // 5. 檢查水平是否溢出 (額外優化)
            if (currentLeft + menuWidth > viewportWidth) {
                // 將選單的左側位置改為 (視窗寬度 - 選單寬度 - 5px緩衝)
                newLeft = viewportWidth - menuWidth - 5;
                if (newLeft < 0) {
                    newLeft = 0;
                }
            }

            // 6. 套用計算後的最終位置
            menu.style.top = newTop + 'px';
            menu.style.left = newLeft + 'px';
        }
    </script>

</body>

</html>